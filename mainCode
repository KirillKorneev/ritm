%%
go = 0;
if go == 1
    t1 = 47.34;
    t2 = 47.41;
    
    % Находим индексы для диапазона времени
    i = find(ptime >= t1, 1, 'first');
    j = find(ptime <= t2, 1, 'last');
    
    % Среднее значение
    mean_val_x = mean(px(i:j));
    mean_val_y = mean(py(i:j));
    
    disp(['Индексы: i = ' num2str(i) ', j = ' num2str(j)]);
    disp(['Среднее x = ' num2str(mean_val_x)]);
    disp(['Среднее y = ' num2str(mean_val_y)]);
end

%%
% find the center of a sphere in image sequences and calculates the pdf(x,y) to obtain the spring constants in x and y
% image sequences can be tiff or better .cxd files, where cxd files are loaded once in the beginning
% requires imageprocessing, parallel , curve fitting toolbx
% consider to increase java memory for matlab, see https://docs.openmicroscopy.org/bio-formats/6.1.0/developers/matlab-dev.html
clear variables
updatetextprogressbar = parallel.pool.DataQueue;afterEach(updatetextprogressbar, @textprogressbar);

%

mumperpix = 100/920;                 % your spatial scaling e.g. 100um for 918 px or use 1 to see results in units of pixel
imgread.showfirstimage   = 0;        % use 1 to show the first image to select the image area (cursor-positions) and 0 for processing all images
imgread.filenamebody     = 'D:\1_McTNexperiments\250911\2\experiment4_*.tif';   % without the numbers and extension, e.g. p266 for p26622_00001.tif % the file extension can be '*.tiff /bmp /png ... or nikon's '*.cxd' file format, the last one combines all images in one file, muc better
imgread.startframe       = 1;        % first file to analyse
imgread.endframe         = 5000;       % last frame
imgread.framestep        = 10;        % also 5 to analyse only every 5th frame and so on
imgread.fps              = [];       % if empty, it will be calculated from start and end times of the image sequence
imgread.xmin    = 400;        % starts at 1, not 0 for croping , in method4 the position is given from the original image, not the croped one 
imgread.ymin    = 0;        % 
imgread.width   = 500;      % width and height, if those numbers very large, the min from image width/hight is used
imgread.height  = 150;
imgread.adjust  = 0;        % use imadjust before computing the shifts
imgread.mag     = 1;        % may be magnification for better detection of position, in particular for method findcircles or fitgaussian
imgread.X0      = [];       % the offset with respect to the full original image of 2048x2048 pixels, taken from the metadata in the .tif images
imgread.Y0      = [];       % so we can compare varius positions from various recordings

% some particular method options                            
method         = 1;        % 1 = fastreg: 2- dft registration, 3 - imregister from matlab; 4 fit an 2D gaussian; 5 using findcircles
method2.usfac  = 1;       % Upsampling factor (integer) - 10 ist sufficient - Images will be registered to within 1/usfac of a pixel. For example usfac = 20 means theimages will be registered within 1/20 of a pixel. (default = 1)
method4.prefind = 1;       % if 1, we search in the first frame for the gaussian and take those result as init for further fits, it speeds up the calculations
method4.amp0   = [];
method4.x0     = [];       % the center of the gaussian, approx or use [] to take the middle of the croped image
method4.y0     = [];       % the center of the gaussian, approx or use [] to take the middle of the croped image
method4.w0     = 8;        % the w = with of the gaussian approximately or use [] to take the 1/8 of the image width
method5.radiusrange = [6 20]; %the bla bla, doesn't work

% data analysis for brownian motion, stiffness k determination
brownanalysis    = 0;     % 1 - yes, we try to determine the spring konstant
movestarttozero  = 0;     % 1 - the starting point is set 0, everyting is moved to the origin 
removeoutlier    = 0;     % for better pdf fitting; if 1 than it takes only the 95% of the datapoins close to the center, 5% are dropped out 
performdirftcorr = 0;     % performs a drift correction using movemedian(..,medianwindowwidth);
medianwindowwidth= 1;    % calculates a moving median for display the positions      
% parallel computing
maxnumcores      = 16;    % if you use 1, no parfor loop is started, otherwise 4 8 or 16 , depends on your # of cpu cores

% start of the main script
warning off;
currentmfile=mfilename('fullpath'); % copy myselfe
[pathstr, name, ext] = fileparts(imgread.filenamebody);
mkdir([pathstr '\Output']);    % create a copy of the program with parameters in the output-dir
datenow = datestr(now,'yyyy-mm-dd-HH-MM-SS');
copyfile([currentmfile '.m'],[pathstr '\output\myTweezerSphere-' datenow '.txt']);
possavefile = [pathstr '\Output\pos' datestr(now,'yyyy-mm-dd-HH-MM-SS') '.mat'];
files = dir(imgread.filenamebody);
imgread.endframe = min(imgread.endframe,size(files,1));
if imgread.xmin < 1 ; imgread.xmin = 1; end; % only to avoid confusing with the 1 in croping, 1 means left border and not 0
if imgread.ymin < 1 ; imgread.ymin = 1; end;
if isempty(imgread.fps)
    firstfile = [files(1).folder filesep files(1).name];lastfile  = [files(end).folder filesep files(end).name];
    tmp1 = Tiff(firstfile).getTag(270); tmp2 = Tiff(lastfile).getTag(270);  % the 270 is the Tag ImageDescription, gives a long char, wehre we look for the timing infos
    k1 = strfind(tmp1,'Time_From_Start =');k2 = strfind(tmp2,'Time_From_Start =');
    time1 = sscanf(tmp1(k1+18:k1+32),'%f:%f:%f');time2 = sscanf(tmp2(k2+18:k2+32),'%f:%f:%f');               % the format is hh:mm:ss.1234
    dt = (time2(1)-time1(1))*3600 + (time2(2)-time1(2))*60 + (time2(3)-time1(3));
    imgread.fps = size(files,1)/dt; clear('tmp1','tmp2','k1','k2','time1','time2','dt');
    fprintf('calculated frame rate: %g fps\n',imgread.fps);
end
if isempty(imgread.X0) % take the capture region from the images itselve
    firstfile = [files(1).folder filesep files(1).name];
    tmp = Tiff(firstfile).getTag(270);  % the 270 is the Tag ImageDescription, gives a long char, wehre we look for the timing infos
    k1 = strfind(tmp,'X0=');k2 = strfind(tmp,'Y0=');
    imgread.X0 = sscanf(tmp(k1+3:k1+3+4),'%f');imgread.Y0 = sscanf(tmp(k2+3:k2+3+4),'%f');               % the format is hh:mm:ss.1234
    fprintf('The offset in pixel of the subimage is X0= %g ; Y0=%g \n',imgread.X0,imgread.Y0)
end
if imgread.showfirstimage == 1       % show always the whole image to select xmin,..
    %imgread.xmin = 0; imgread.ymin = 0; imgread.width = 6000; imgread.hight = 6000;
    img = readimage(files,imgread.startframe,imgread);
    figure(1);clf;imshow(imadjust(img),[]); axis on; title('select values for xmin ymin width hight');
    disp('first image is shown, we are done');
    return
end
if method == 4 && method4.prefind == 1       % if 1, we search in the first frame for the gaussian and take those result as init for further fits, it speeds up the calculations
    img = readimage(files,imgread.startframe,imgread);
    method4.showfitresult = 1;
    fitresult = fit2dGaussian(img,method4);
    method4.showfitresult = 0;
    method4.amp0 = abs(fitresult.amp); method4.w0 = abs(fitresult.w);method4.x0 = abs(fitresult.x0); method4.y0 = abs(fitresult.y0); % here in pixels, all must be positive>0
end
% processing the analysis of all images
img = readimage(files,imgread.startframe,imgread);
imgnum = imgread.startframe:imgread.framestep:imgread.endframe;    % a vector of images to analyze
Nimg = length(imgnum); % we will go over this images, for parfor the loop variable must increases always by 1
fprintf('We analyse %d images with an fps of: %g\n',Nimg,imgread.fps);
ptime = imgnum' ; 
px = NaN(Nimg,1); py = NaN(Nimg,1);pdx = NaN(Nimg,1) ; pdy = NaN(Nimg,1);    
% main loop starts here
tic
textprogressbar('start ',Nimg); % call the funtion with two arguments for init
for ii = 2:Nimg    % starting at 2 because fastreg needs the picture before ii in the loop
    send(updatetextprogressbar,[' additions text - current N=' num2str(ii) ' '] ); % this send accepts only 1 argument, a    
    img = readimage(files,imgnum(ii),imgread);
    % if mod(ii,100) == 0
    %     fprintf('img# =  %g , ',ii);
    %     figure(100);imagesc(img); axis image;colormap gray;title(['Current file number ' num2str(ii) ' of ' num2str(Nimg)]);drawnow;
    % end        
    switch method
        case 1 % fastreg
            lastimg = readimage(files,imgnum(ii-1),imgread); % for the first image and convert to double, for analysis
            [dx, dy] = fastreg(lastimg,img);                
            pdx(ii) = -dx; pdy(ii) = -dy;
        case 2 % dftregistration             
            lastimg = readimage(files,imgnum(ii-1),imgread); % for the first image and convert to double, for analysis
            output = dftregistration(fft2(lastimg),fft2(img),method2.usfac); % in output 3 and 4 are the shifts
            pdx(ii) = -output(3); pdy(ii) = -output(4);
        case 3 % matlab imregtform
            lastimg = readimage(files,imgnum(ii-1),imgread); % for the first image and convert to double, for analysis
            [optimizer,metric] = imregconfig('monomodal');
            tform = imregtform(img,lastimg,'translation',optimizer, metric);
            pdx(ii) = -tform.Translation(2); pdy(ii) = -tform.Translation(1);
        case 4 % fit an 2d gaussian
            fitresult = fit2dGaussian(img,method4);
            px(ii) = abs(fitresult.x0); py(ii) =abs(fitresult.y0);
        case 5 % try to find circles in the image, stupid idea
            simg = size(img);
            ypx = round(simg(2)/10);xpx=round(simg(2)/10); % take 10 % of the border width
            imborderpx = [ reshape(img(1:ypx,:),[],1) ; reshape(img(end-ypx:end,:),[],1) ; reshape(img(:,1:xpx),[],1) ; reshape(img(:,end-xpx:end),[],1) ] ;
            immed = median(imborderpx);                   % this is the approx gray value of the enviroment
            %img = imfill(abs(img-immed),'holes');
            [centers,radii] = imfindcircles(img,method5.radiusrange,ObjectPolarity="bright");
            if ~isempty(centers)
                px(ii) = centers(1); py(ii) = centers(2);
            end
    end
end
textprogressbar(' end ',0);  % call the funtion with two arguments also for exit
toc
if method<4 % we collect only position differences, cumsum gives the positions itself
    px = cumsum(pdx,"omitnan");py = cumsum(pdy,"omitnan");
end
% remove all what is nan
idx = not( or(isnan(ptime) , isnan(px)) ); 
ptime = ptime(idx); px = px(idx); py= py(idx);
% add the xmin and ymin to obtain the position in the original image
px = px +imgread.xmin-1+imgread.X0;py = py +imgread.ymin-1+imgread.Y0; % the -1 because imcrope(a,[1 1 10000 100000]) does not change the picture
%convert to s and um
ptime = ptime/imgread.fps; px = px*mumperpix; py = py*mumperpix;
% save the results
p.time=ptime;p.x=px;p.y=py;
save(possavefile,"p","imgread","method");
tmp=[];tmp(:,1) = ptime;tmp(:,2) = px; tmp(:,3) = py;
save([possavefile '.dat'],"tmp","-ascii","-tabs");
% move the starting point to (0,0)
if movestarttozero
    px = px - px(1);
    py = py - py(1);
end
% perform drift correction linear polynom subtracted
if performdirftcorr % we subract the calculated moving median
    px = px-movmedian(px,medianwindowwidth);
    py = py-movmedian(py,medianwindowwidth);
end
%% plot the results
figure(1);
    subplot(211);plot(ptime,px,ptime,movmedian(px,medianwindowwidth),'.-');xlabel('time [s]');ylabel('pos x [um]');title('particle in the tweezer');hold all;
    subplot(212);plot(ptime,py,ptime,movmedian(py,medianwindowwidth),'.-');xlabel('time [s]');ylabel('pos y [um]');hold all;   
figure(2);title('trajectories x-y-plot');
    plot(px,py,'.');xlabel('pos x [um]');ylabel('pos y [um]');axis equal;hold all;
figure(3);clf;     % create the pdf in x and y direction 
if brownanalysis
    [bandwidth,pdfx,xi,cdf]=kde(px,200,min(px),max(px));
    [bandwidth,pdfy,yi,cdf]=kde(py,200,min(py),max(py));
    subplot(211);plot(xi,pdfx,'r-');hold all;plot(yi,pdfy,'b-');xlabel('position [um]');ylabel('pdf [1/um]');title({'probaility density function','of positions'});legend('x-pos','y-pos');
    subplot(212);semilogy(xi,pdfx,'r-');hold all;semilogy(yi,pdfy,'b-');xlabel('position [um]');ylabel('pdf [1/um]');ylim([max(1e-4,min([pdfx;pdfy])) 2*max([pdfx ; pdfy])]);
    figure(4);clf;     % show the 2D pdf
    p = gkde2([px , py ]); % the result is inside the struct of p
    p.pdf(end,end) = -10; % one point at a low position for better 3d surface
    sc=surfc(p.x , p.y , p.pdf);shading interp;colormap jet;xlabel('x-pos [um]');ylabel('y-pos [um]');zlabel('pdf [1/um^2]'); title('2D pdf');    
    Deltax = max(p.x(:))-min(p.x(:)); Deltay = max(p.y(:))-min(p.y(:)); Delta = max(Deltax, Deltay);
    xlim( [ min(p.x(:)) , min(p.x(:))+Delta ] );
    ylim( [ min(p.y(:)) , min(p.y(:))+Delta ] );
    ax = gca;sc(2).ZLocation = 'zmax';
    %% remove outlier for fitting
    xifull = sort(px);yifull = sort(py); % save for later usage
    if removeoutlier
         disp('removing 5% of datapoints for better pdf fitting');
         dists = sqrt(px.^2+py.^2);
         qlow  = prctile(dists,2.5);
         qhigh = prctile(dists,97.5);
         idx   = (dists>qlow & dists<qhigh);
         px = px(idx);
         py = py(idx);
         ptime = ptime(idx);
    end        
    % fit the pdf to P0*exp(-k/(2*kB*T)*x^2 = p0*exp(-a*x^2); a in um^(-2); k = a*2*kB*T with kB = 1.38e-23 Nm/K = 1.38e-5pN µm/K   
    [bandwidth,pdfx,xi,cdf]=kde(px,200,min(px),max(px));  % update the pdf with outlier
    [bandwidth,pdfy,yi,cdf]=kde(py,200,min(py),max(py));
    polyx = polyfit(xi,log(pdfx),2);  % fit to polynom 2. order
    polyy = polyfit(yi,log(pdfy),2);  % fit to polynom 2. order
    fitx = exp(polyval(polyx,xifull));
    fity = exp(polyval(polyy,yifull));
    figure(3);subplot(212);semilogy(xifull,fitx,'r--');semilogy(yifull,fity,'b--');legend('x-pos','y-pos','x-pos fit','y-pos fit');
    fprintf('Results on %s using method %i\n',imgread.filenamebody , method);
    fprintf('pdf(xpos) = p0x*exp(a*x^2); a-fit = %0.3f 1/um^2 , lin=%0.3f , log(p0)= %0.3f\n',polyx(1),polyx(2),polyx(3));
    fprintf('pdf(ypos) = p0y*exp(a*y^2); a-fit = %0.3f 1/um^2 , lin=%0.3f , log(p0)= %0.3f\n',polyy(1),polyy(2),polyy(3));
    fprintf('k_x =  %0.2f pN/µm\n',-polyx(1)*2*1.38e-5*(273+22) );
    fprintf('k_y =  %0.2f pN/µm\n',-polyy(1)*2*1.38e-5*(273+22) );
end
disp('We are done, have a pleasant day ');

%%------------------- end of the main script, here start of functions


function img = readimage(files,imgnum,imgread)  
  warning off; % sometimes warnings from stange image infos
  img = Tiff([files(imgnum).folder filesep files(imgnum).name]).read();
  img = double(img)/2^16;          % 2^16 is the bitdeph of the orca flash 4 tiffs
  img = imcrop(img,[imgread.xmin imgread.ymin imgread.width imgread.height]);
  if imgread.adjust
      img = imadjust(img); % map exactly between 0 and 1, full range for double
  end
  if ~(imgread.mag==1)
      img = imresize(img,imgread.mag);
  end
end

%%------------------ function to fit a 2d gaussian -------------------
function result = fit2dGaussian(img,p); % in p are the parameters
    simg = size(img);
    ypx = round(simg(1)/10);xpx=round(simg(2)/10); % take 10 % of the border width
    imborderpx = [reshape(img(1:ypx,:),[],1) ; reshape(img(end-ypx:end,:),[],1) ; reshape(img(:,1:xpx),[],1) ; reshape(img(:,end-xpx:end),[],1) ] ;
    immed = median(imborderpx);                   % this is the approx gray value of the enviroment
    img = imfill(abs(img-immed),'holes');         % the difference to the immed is importand
    % fit to a 2D Gaussian, using lsqcurvefit method in matlab, no rotation, see https://de.mathworks.com/matlabcentral/fileexchange/113230-fitgaussbeam
    ft=fittype('amp*exp(-((x-x0).^2+(y-y0).^2)./(w)^2)', 'independent',{'x','y'}, 'dependent','z');    
    % The coefficients are stored in this order: amp, noise, w, x0, y0. 
    if isempty(p.amp0)
        amp0 = max(img(:));
    else
        amp0 = p.amp0;
    end
    if isempty(p.w0)
        w0 = size(img,1)/8;
    else
        w0 = p.w0;
    end
    if isempty(p.x0)
        x0 = size(img,2)/2; 
    else
        x0 = p.x0;
    end
    if isempty(p.y0)
        y0 = size(img,1)/2;
    else
        y0 = p.y0;
    end
    opts = fitoptions( 'Method', 'NonlinearLeastSquares' );
    opts.Algorithm = 'Trust-Region'; % To deal with boundaries.
    opts.Lower=     [0    0    0    0  ];
    opts.Upper=     [Inf  Inf  Inf  Inf];
    opts.StartPoint=[amp0 w0   x0   y0 ];
    [xData,yData,zData]=prepareSurfaceData(0:size(img,2)-1, 0:size(img,1)-1, img);
    fitresult = fit([xData,yData], zData, ft, opts);
    if p.showfitresult % only enabled once for the first fit, take a lot of time to draw
        figure(101);clf;
        mesh(img,'EdgeColor',[0 0 0]);hold all;plot(fitresult);shading interp;alpha 0.8;
        xlabel('xpos [px]');ylabel('ypos [px]');zlabel('intens [0..1]');
        title({'comparison of given intensities and 2d-Gauss fitted intensities',sprintf('x0 = %0.1f , y0 = %0.1f , w = %0.1f, amp = %0.2f',fitresult.x0,fitresult.y0,fitresult.w,fitresult.amp)});
    end
    result = fitresult;
end


%%------------------ function to detect shift between two images ------------------------ 
function [m n] = fastreg(standimage,compimage)
    % function [m n]=fastreg(standimage,compimage):
    % A very fast subpixel image registration or alignment based on cross correlation
    % and modified moment algorithm . Its accuracy is around 0.01-0.1 pixel
    % according to the SNR and the size of images.
    % Inputs
    % standimage: the first image
    % compimage:  the second image. It should be the same size as the first image
    % Outputs
    % m: the shift in X
    % n: the shift in Y
    % This code is implemented based on the following algorithm. Please cite
    % it.
    % http://ieeexplore.ieee.org/xpl/articleDetails.jsp?tp=&arnumber=6463241
    % Song Min, June, 2013
    [M N]=size(standimage);
    standimage=double(standimage);
    compimage=double(compimage);
    R0=2;
    R1=R0+5;
    % pixel level registration
    [M0 N0]=regsurf(standimage,compimage);
    M0=floor(M0-M/2-1);
    N0=floor(N0-N/2-1);
    compimage=circshift(compimage,[M0,N0]);
    standimage2=standimage(abs(M0)+1:end-abs(M0),abs(N0)+1:end-abs(N0));
    compimage2=compimage(abs(M0)+1:end-abs(M0),abs(N0)+1:end-abs(N0));
    %subpixel level registration
    [M N]=size(standimage2);
    if min(M,N)<500;
        w=1;
    else
        wm=gausswin(M);
        wn=gausswin(N);
        w=wm(:)*wn(:)';
    end
    [m n im]=regsurf((standimage2.*w),(compimage2.*w));
    try
        [x y]=meshgrid(-R1:R1,-R1:R1);
        immin=min(min(im((m-R0):(m+R0),(n-R0):(n+R0))));
        im=max(im-immin,0);
        im0=im(m-R1:m+R1,n-R1:n+R1);
        area = sum(im0(:));
        n = sum(sum(im0.*x))/area+n;
        m = sum(sum(im0.*y))/area+m;
        m=m-M/2-1;
        n=n-N/2-1;
        if mod(M,2)
            m=m+0.5;
        end
        if mod(N,2)
            n=n+0.5;
        end
    catch
        m=0;
        n=0;
    end
    m=m+M0;
    n=n+N0;
end

function [m n im] = regsurf(standimage,compimage)
    s=fft2(standimage);
    c=ifft2(compimage);
    sc=s.*c;
    im=abs(fftshift(ifft2(sc)));
    [M0 N0]=find(im==max(im(:)));
    m=round(mean(M0));
    n=round(mean(N0));
end

%% ------------------  kernel density estimator for 2d data
function p=gkde2(x,p)
    % function p=gkde2(x,N,h,xylim,alpha)
    % GKDE2  Bivariate Gaussian Kernel Density Estimation
    % 
    % Usage:
    % p = gkdeb(d) returns an estmate of the probability density function (pdf)
    %             and the cumulative distribution function (cdf) of the given
    %             random data d in p, where p.pdf and p.cdf are the pdf and cdf
    %             vectors estimated at locations of (p.x, p.y), respectively
    %             and p.h is the bandwidth used for the estimation. 
    % p = gkdeb(d,p) specifies optional parameters for the estimation:
    %             p.h  - 1x2 vector for bandwidth, [hx, hy]
    %             p.xy - Nx2 matrix for locations to make estimation
    %             p.xylim - 1x4 location limits as [xmin ymin xmax ymax]
    %             p.alpha - a vector of probabilities to calculate inverse cdfs.
    %
    % Without output, gkdeb(d) and gkdeb(d,p) will disply the pdf and cdf plots.  
    %
    % See also: hist, histc, ksdensity, ecdf, cdfplot, ecdfhist
    
    % Example 1: two-peak normal distribution
    %{
    gkde2([randn(500,2);randn(500,1)+5 randn(500,1)]);
    %}
    % Example 2: four-peak normal distribution
    %{
    gkde2([randn(100,1), (randn(100,1)-10)*2;
          randn(100,1)+10, randn(100,1);
          randn(100,1)+10, (randn(100,1)-10)*2;
          randn(100,2)]);
    %}
    % Example 3: uniform distribution
    %{
    clear p
    p.xylim=[0 0 1 1];
    gkde2(rand(500,2),p);
    %}
    % Example 4: dumbbell density
    %{
    X1=[randn(2000,1)-2 randn(2000,1)+2];
    X2=randn(2000,2)*inv([0.8 -0.72;-0.72 0.8]);
    X3=[randn(2000,1)+2 randn(2000,1)-2];
    p=gkde2(((X1+X3)*4+X2*3)/11);
    figure
    contour(p.x,p.y,p.pdf,20);
    figure
    contour(p.x,p.y,p.cdf,20);
    %}
    
    % V2.1 by Yi Cao at Cranfield University on 10th August 2013
    %
    
    % Check input and output
    error(nargchk(1,2,nargin));
    error(nargoutchk(0,1,nargout));
    [nr, nc] = size(x);
    if nr ~= 2 && nc ~= 2
        error('Bivariate data required!');
    end
    if nc>nr
        x=x';
    end 
    n=length(x);
    % Default parameters
    if nargin<2
        N=50;
        % rule of thumb bandwidth suggested by Bowman and Azzalini (1997) p.31
        h=median(abs(x-repmat(median(x),n,1)))/0.6745*(1/n)^(1/6);
        xylim=[-inf -inf inf inf];
        xmax=max(x);
        xmin=min(x);
        xmax=min([xmax+3*h;xylim(3:4)]);
        xmin=max([xmin-3*h;xylim(1:2)]);
        x1=linspace(xmin(1),xmax(1),N);
        x2=linspace(xmin(2),xmax(2),N);
        [px,py]=meshgrid(x1,x2);
        X=[px(:) py(:)];
        p.x=px;
        p.y=py;
        p.h=h;
        p.xylim=xylim;
        dxdz=ones(N*N,1);
        p.N=N;
    else % check parameters with default setting
        [p,x,dxdz,X]=checkp(x,p);
        N=p.N;
        xmin = min(X);
        xmax = max(X);
    end
    dxdz=dxdz/n;
    p.pdf=zeros(N,N);
    p.cdf=zeros(N,N);
    N2=N*N;
    
    % Bivariant Gaussian kernel function
    kerf=@(t)exp(-sum(t.*t,2)/2)/(2*pi);
    % cdf estimation based on A. Genz, Statistics and Computing 14:251–260, 2004
    ckerf=@(t)prod(erfc(-t ./ sqrt(2))/2,2);
    for k=1:N2
        h=min([min([X(k,:)-xmin;p.h]);min([xmax-X(k,:);p.h])]);
        if prod(h)<sqrt(eps)
            p.pdf(k)=0;
            r = mod(k-1,N)+1;
            c = ceil(k/N);        
            p.cdf(k)=max(max(p.cdf(1:r,1:c)));
            continue
        end
        z=(X(k+zeros(n,1),:)-x)./h(ones(n,1),:);
        p.pdf(k)=sum(kerf(z))/prod(h);
        p.cdf(k)=sum(ckerf(z));
    end
    % p.cdf=cumsum(p.pdf);
    % p.cdf=cumsum(p.cdf,2)*prod((xmax-xmin)/N);
    p.pdf(:)=p.pdf(:).*dxdz(:);
    p.cdf=p.cdf/n;
    p.cdf(p.cdf>1)=1;
    p.cdf(p.cdf<0)=0;
    
    % calculate icdf
    if isfield(p,'alpha')
        C=contour(p.x,p.y,p.cdf,[p.alpha p.alpha]);
        p.icdfx = min(C(1,2:end));
        p.icdfy = min(C(2,2:end));
    end
    
    
    % Plot results
    if ~nargout
        xLim=[min(p.x(:)) max(p.x(:))];
        yLim=[min(p.y(:)) max(p.y(:))];
        subplot(221)
        mesh(p.x,p.y,p.pdf);
        xlabel('x');
        ylabel('y')
        zlabel('p(x)')
        title('Estimated Probability Density Function');
        set(gca,'XLim',xLim,'YLim',yLim)
        subplot(222)
        mesh(p.x,p.y,p.cdf);
        xlabel('x');
        ylabel('y')
        zlabel('F(x)')
        title('Estimated Cumlative Distribution Function');
        set(gca,'XLim',xLim,'YLim',yLim,'ZLim',[0 1.1])
        subplot(223)
        contour(p.x,p.y,p.pdf);
        xlabel('x');
        ylabel('y')
        zlabel('p(x)')
        title('Contour of Probability Density Function');
        set(gca,'XLim',xLim,'YLim',yLim)
        subplot(224)
        contour(p.x,p.y,p.cdf);
        xlabel('x');
        ylabel('y')
        zlabel('F(x)')
        set(gca,'XLim',xLim,'YLim',yLim)
        if isfield(p,'alpha')
            title(sprintf('icdf_x = %g, icdf_y = %g',p.icdfx,p.icdfy))
        else
            title('Contour of Cumlative Distribution Function');        
        end
    end
end

function [p,x,dxdz,z]=checkp(x,p)
    %check structure p
    if ~isstruct(p)
        error('p is not a structure.');
    end
    if ~isfield(p,'xylim')
        p.xylim=[-Inf -Inf Inf Inf];
    end
    if ~isfield(p,'N')
        p.N=50;
    end
    px.N=p.N;
    py.N=p.N;
    if isfield(p,'h')
        px.h=p.h(1);
        py.h=p.h(2);
    end
    % px = p;
    % py = p;
    if isfield(p,'x')
        px.x = p.x(:);
    end
    if isfield(p,'y')
        py.x=p.y(:);
    end
    px.lB = p.xylim(1);
    py.lB = p.xylim(2);
    px.uB = p.xylim(3);
    py.uB = p.xylim(4);
    [px,X,dXdz,zx] = bounded(x(:,1),px);
    [py,Y,dYdz,zy] = bounded(x(:,2),py);
    if isfield(p,'x') && isfield(p,'y')  
        p.x = reshape(zx,p.N,[]);
        p.y = reshape(zy,p.N,[]);
        z = [px.x py.x];
        dxdz=dXdz.*dYdz;
    else
        [p.x,p.y]=meshgrid(zx,zy);
        [zx,zy]=meshgrid(px.x,py.x);
        z = [zx(:) zy(:)];
        dxdz=dYdz(:)*dXdz(:)';
    end
    p.h = [px.h py.h];
    x = [X Y];
end
    
function [p,x,dxdz,z]=bounded(x,p)
    n=length(x);
    if p.lB>-Inf || p.uB<Inf
        if p.lB==-Inf
            % function for (dx_bound)/(dx_unbounded)
            dx=@(t)1./(p.uB-t);
            % function for converting x_bounded to x_unbounded 
            y=@(t)-log(p.uB-t);
            % function for converting x_unbounded to x_bounded
            zf=@(t)(p.uB-exp(-t));
        elseif p.uB==Inf
            dx=@(t)1./(t-p.lB);
            y=@(t)log(t-p.lB);
            zf=@(t)exp(t)+p.lB;
        else
            dx=@(t)(p.uB-p.lB)./(t-p.lB)./(p.uB-t);
            y=@(t)log((t-p.lB)./(p.uB-t));
            zf=@(t)(exp(t)*p.uB+p.lB)./(exp(t)+1);
        end
        x=y(x);
        n=numel(x);
        if ~isfield(p,'h')
            p.h=median(abs(x-median(x)))/0.6745*(4/3/n)^0.2;
        end
        h=p.h;
        if ~isfield(p,'x')
            N=p.N;
            xmax=max(x)+3*h;
            xmin=min(x)-3*h;
            p.x=linspace(xmin,xmax,N);
            z=zf(p.x);
        else
            z=p.x;
            p.x=y(p.x);
        end
        dxdz=dx(z);
    else
        if ~isfield(p,'h')
            p.h=median(abs(x-median(x)))/0.6745*(4/3/n)^0.2;
        end
        error(varchk(eps, inf, p.h, 'Bandwidth, p.h is not positive.'));
        if ~isfield(p,'x')
            N=p.N;
            xmax=max(x);
            xmin=min(x);
            xmax=min(xmax+3*p.h,p.uB);
            xmin=max(xmin-3*p.h,p.lB);
            p.x=linspace(xmin,xmax,N);
        end
        dxdz=ones(size(p.x(:)));
        z=p.x;
    end
end

function msg=varchk(low,high,n,msg)
    % check if variable n is not between low and high, returns msg, otherwise
    % empty matrix
    if all(n>=low) && all(n<=high)
        msg=[];
    end
end

%%---------- kernel density estimator in matlab as ksdensity, but octave doesn't know it
function [bandwidth,density,xmesh,cdf]=kde(data,n,MIN,MAX)
    % Reliable and extremely fast kernel density estimator for one-dimensional data;
    %        Gaussian kernel is assumed and the bandwidth is chosen automatically;
    %        Unlike many other implementations, this one is immune to problems
    %        caused by multimodal densities with widely separated modes (see example). The
    %        estimation does not deteriorate for multimodal densities, because we never assume
    %        a parametric model for the data.
    % INPUTS:
    %     data    - a vector of data from which the density estimate is constructed;
    %          n  - the number of mesh points used in the uniform discretization of the
    %               interval [MIN, MAX]; n has to be a power of two; if n is not a power of two, then
    %               n is rounded up to the next power of two, i.e., n is set to n=2^ceil(log2(n));
    %               the default value of n is n=2^12;
    %   MIN, MAX  - defines the interval [MIN,MAX] on which the density estimate is constructed;
    %               the default values of MIN and MAX are:
    %               MIN=min(data)-Range/10 and MAX=max(data)+Range/10, where Range=max(data)-min(data);
    % OUTPUTS:
    %   bandwidth - the optimal bandwidth (Gaussian kernel assumed);
    %     density - column vector of length 'n' with the values of the density
    %               estimate at the grid points;
    %     xmesh   - the grid over which the density estimate is computed;
    %             - If no output is requested, then the code automatically plots a graph of
    %               the density estimate.
    %        cdf  - column vector of length 'n' with the values of the cdf
    %  Reference:
    % Kernel density estimation via diffusion
    % Z. I. Botev, J. F. Grotowski, and D. P. Kroese (2010)
    % Annals of Statistics, Volume 38, Number 5, pages 2916-2957.
    %
    %  Example:
    %           data=[randn(100,1);randn(100,1)*2+35 ;randn(100,1)+55];
    %              kde(data,2^14,min(data)-5,max(data)+5);
    data=data(:); %make data a column vector
    if nargin<2 % if n is not supplied switch to the default
        n=2^14;
    end
    n=2^ceil(log2(n)); % round up n to the next power of 2;
    if nargin<4 %define the default  interval [MIN,MAX]
        minimum=min(data); maximum=max(data);
        Range=maximum-minimum;
        MIN=minimum-Range/2; MAX=maximum+Range/2;
    end
    % set up the grid over which the density estimate is computed;
    R=MAX-MIN; dx=R/(n-1); xmesh=MIN+[0:dx:R]; N=length(unique(data));
    %bin the data uniformly using the grid defined above;
    initial_data=histc(data,xmesh)/N;  initial_data=initial_data/sum(initial_data);
    a=dct1d(initial_data); % discrete cosine transform of initial data
    % now compute the optimal bandwidth^2 using the referenced method
    I=[1:n-1]'.^2; a2=(a(2:end)/2).^2;
    % use  fzero to solve the equation t=zeta*gamma^[5](t)
    t_star=root(@(t)fixed_point(t,N,I,a2),N);
    % smooth the discrete cosine transform of initial data using t_star
    a_t=a.*exp(-[0:n-1]'.^2*pi^2*t_star/2);
    % now apply the inverse discrete cosine transform
    if (nargout>1)|(nargout==0)
        density=idct1d(a_t)/R;
    end
    % take the rescaling of the data into account
    bandwidth=sqrt(t_star)*R;
    density(density<0)=eps; % remove negatives due to round-off error
    if nargout==0
        figure(1), plot(xmesh,density)
    end
    % for cdf estimation
    if nargout>3
        f=2*pi^2*sum(I.*a2.*exp(-I*pi^2*t_star));
        t_cdf=(sqrt(pi)*f*N)^(-2/3);
        % now get values of cdf on grid points using IDCT and cumsum function
        a_cdf=a.*exp(-[0:n-1]'.^2*pi^2*t_cdf/2);
        cdf=cumsum(idct1d(a_cdf))*(dx/R);
        % take the rescaling into account if the bandwidth value is required
        bandwidth_cdf=sqrt(t_cdf)*R;
    end
end

function  out=fixed_point(t,N,I,a2)
    % this implements the function t-zeta*gamma^[l](t)
    l=7;
    f=2*pi^(2*l)*sum(I.^l.*a2.*exp(-I*pi^2*t));
    for s=l-1:-1:2
        K0=prod([1:2:2*s-1])/sqrt(2*pi);  const=(1+(1/2)^(s+1/2))/3;
        time=(2*const*K0/N/f)^(2/(3+2*s));
        f=2*pi^(2*s)*sum(I.^s.*a2.*exp(-I*pi^2*time));
    end
    out=t-(2*N*sqrt(pi)*f)^(-2/5);
end

function out = idct1d(data)
    % computes the inverse discrete cosine transform
    [nrows,ncols]=size(data);
    % Compute weights
    weights = nrows*exp(i*(0:nrows-1)*pi/(2*nrows)).';
    % Compute x tilde using equation (5.93) in Jain
    data = real(ifft(weights.*data));
    % Re-order elements of each column according to equations (5.93) and
    % (5.94) in Jain
    out = zeros(nrows,1);
    out(1:2:nrows) = data(1:nrows/2);
    out(2:2:nrows) = data(nrows:-1:nrows/2+1);
    %   Reference:
    %      A. K. Jain, "Fundamentals of Digital Image
    %      Processing", pp. 150-153.
end

function data=dct1d(data)
    % computes the discrete cosine transform of the column vector data
    [nrows,ncols]= size(data);
    % Compute weights to multiply DFT coefficients
    weight = [1;2*(exp(-i*(1:nrows-1)*pi/(2*nrows))).'];
    % Re-order the elements of the columns of x
    data = [ data(1:2:end,:); data(end:-2:2,:) ];
    % Multiply FFT by weights:
    data= real(weight.* fft(data));
end

function t=root(f,N)
    % try to find smallest root whenever there is more than one
    N=50*(N<=50)+1050*(N>=1050)+N*((N<1050)&(N>50));
    tol=10^-12+0.01*(N-50)/1000;
    flag=0;
    while flag==0
        try
            t=fzero(f,[0,tol]);
            flag=1;
        catch
            tol=min(tol*2,.1); % double search interval
        end
        if tol==.1 % if all else fails
            t=fminbnd(@(x)abs(f(x)),0,.1); flag=1;
        end
    end
end

%% ------------------- other function to detect image shifts -------------------------------

function [output, Greg] = dftregistration(buf1ft,buf2ft,usfac)
% function [output Greg] = dftregistration(buf1ft,buf2ft,usfac);
% Efficient subpixel image registration by crosscorrelation. This code
% gives the same precision as the FFT upsampled cross correlation in a
% small fraction of the computation time and with reduced memory 
% requirements. It obtains an initial estimate of the crosscorrelation peak
% by an FFT and then refines the shift estimation by upsampling the DFT
% only in a small neighborhood of that estimate by means of a 
% matrix-multiply DFT. With this procedure all the image points are used to
% compute the upsampled crosscorrelation.
% Manuel Guizar - Dec 13, 2007
%
% Rewrote all code not authored by either Manuel Guizar or Jim Fienup
% Manuel Guizar - May 13, 2016
%
% Citation for this algorithm:
% Manuel Guizar-Sicairos, Samuel T. Thurman, and James R. Fienup, 
% "Efficient subpixel image registration algorithms," Opt. Lett. 33, 
% 156-158 (2008).
%
% Inputs
% buf1ft    Fourier transform of reference image, 
%           DC in (1,1)   [DO NOT FFTSHIFT]
% buf2ft    Fourier transform of image to register, 
%           DC in (1,1) [DO NOT FFTSHIFT]
% usfac     Upsampling factor (integer). Images will be registered to 
%           within 1/usfac of a pixel. For example usfac = 20 means the
%           images will be registered within 1/20 of a pixel. (default = 1)
%
% Outputs
% output =  [error,diffphase,net_row_shift,net_col_shift]
% error     Translation invariant normalized RMS error between f and g
% diffphase     Global phase difference between the two images (should be
%               zero if images are non-negative).
% net_row_shift net_col_shift   Pixel shifts between images
% Greg      (Optional) Fourier transform of registered version of buf2ft,
%           the global phase difference is compensated for.
%
%
% Copyright (c) 2016, Manuel Guizar Sicairos, James R. Fienup, University of Rochester
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are
% met:
% 
%     * Redistributions of source code must retain the above copyright
%       notice, this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in
%       the documentation and/or other materials provided with the distribution
%     * Neither the name of the University of Rochester nor the names
%       of its contributors may be used to endorse or promote products derived
%       from this software without specific prior written permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%% Syntax
% The code receives the FFT of the reference and the shifted images, and an
% (integer) upsampling factor. The code expects FFTs with DC in (1,1) so do not use
% fftshift.
%
%    output = dftregistration(fft2(f),fft2(g),usfac);
%
% The images are registered to within 1/usfac of a pixel.
%
% output(1) is the normalized root-mean-squared error (NRMSE) [1] between f and
% g. 
%
% output(2) is the global phase difference between the two images (should be
% zero if images are real-valued and non-negative).
%
% output(3) and output(4) are the row and column shifts between f and g respectively. 
%
%    [output Greg] = dftregistration(fft2(f),fft2(g),usfac);
%
% Greg is an optional output, it returns the Fourier transform of the registered version of g,
% where the global phase difference [output(2)] is also compensated.

if ~exist('usfac','var')
    usfac = 1;
end
[nr,nc]=size(buf2ft);
Nr = ifftshift(-fix(nr/2):ceil(nr/2)-1);
Nc = ifftshift(-fix(nc/2):ceil(nc/2)-1);
if usfac == 0
    % Simple computation of error and phase difference without registration
    CCmax = sum(buf1ft(:).*conj(buf2ft(:)));
    row_shift = 0;
    col_shift = 0;
elseif usfac == 1
    % Single pixel registration
    CC = ifft2(buf1ft.*conj(buf2ft));
    CCabs = abs(CC);
    [row_shift, col_shift] = find(CCabs == max(CCabs(:)));
    CCmax = CC(row_shift,col_shift)*nr*nc;
    % Now change shifts so that they represent relative shifts and not indices
    row_shift = Nr(row_shift);
    col_shift = Nc(col_shift);
elseif usfac > 1
    % Start with usfac == 2
    CC = ifft2(FTpad(buf1ft.*conj(buf2ft),[2*nr,2*nc]));
    CCabs = abs(CC);
    [row_shift, col_shift] = find(CCabs == max(CCabs(:)),1,'first');
    CCmax = CC(row_shift,col_shift)*nr*nc;
    % Now change shifts so that they represent relative shifts and not indices
    Nr2 = ifftshift(-fix(nr):ceil(nr)-1);
    Nc2 = ifftshift(-fix(nc):ceil(nc)-1);
    row_shift = Nr2(row_shift)/2;
    col_shift = Nc2(col_shift)/2;
    % If upsampling > 2, then refine estimate with matrix multiply DFT
    if usfac > 2,
        %%% DFT computation %%%
        % Initial shift estimate in upsampled grid
        row_shift = round(row_shift*usfac)/usfac; 
        col_shift = round(col_shift*usfac)/usfac;     
        dftshift = fix(ceil(usfac*1.5)/2); %% Center of output array at dftshift+1
        % Matrix multiply DFT around the current shift estimate
        CC = conj(dftups(buf2ft.*conj(buf1ft),ceil(usfac*1.5),ceil(usfac*1.5),usfac,...
            dftshift-row_shift*usfac,dftshift-col_shift*usfac));
        % Locate maximum and map back to original pixel grid 
        CCabs = abs(CC);
        [rloc, cloc] = find(CCabs == max(CCabs(:)),1,'first');
        CCmax = CC(rloc,cloc);
        rloc = rloc - dftshift - 1;
        cloc = cloc - dftshift - 1;
        row_shift = row_shift + rloc/usfac;
        col_shift = col_shift + cloc/usfac;    
    end
    % If its only one row or column the shift along that dimension has no
    % effect. Set to zero.
    if nr == 1,
        row_shift = 0;
    end
    if nc == 1,
        col_shift = 0;
    end
    
end  
rg00 = sum(abs(buf1ft(:)).^2);
rf00 = sum(abs(buf2ft(:)).^2);
error = 1.0 - abs(CCmax).^2/(rg00*rf00);
error = sqrt(abs(error));
diffphase = angle(CCmax);
output=[error,diffphase,row_shift,col_shift];
% Compute registered version of buf2ft
if (nargout > 1)&&(usfac > 0),
    [Nc,Nr] = meshgrid(Nc,Nr);
    Greg = buf2ft.*exp(1i*2*pi*(-row_shift*Nr/nr-col_shift*Nc/nc));
    Greg = Greg*exp(1i*diffphase);
elseif (nargout > 1)&&(usfac == 0)
    Greg = buf2ft*exp(1i*diffphase);
end
return
end

function out=dftups(in,nor,noc,usfac,roff,coff)
% function out=dftups(in,nor,noc,usfac,roff,coff);
% Upsampled DFT by matrix multiplies, can compute an upsampled DFT in just
% a small region.
% usfac         Upsampling factor (default usfac = 1)
% [nor,noc]     Number of pixels in the output upsampled DFT, in
%               units of upsampled pixels (default = size(in))
% roff, coff    Row and column offsets, allow to shift the output array to
%               a region of interest on the DFT (default = 0)
% Recieves DC in upper left corner, image center must be in (1,1) 
% Manuel Guizar - Dec 13, 2007
% Modified from dftus, by J.R. Fienup 7/31/06
% This code is intended to provide the same result as if the following
% operations were performed
%   - Embed the array "in" in an array that is usfac times larger in each
%     dimension. ifftshift to bring the center of the image to (1,1).
%   - Take the FFT of the larger array
%   - Extract an [nor, noc] region of the result. Starting with the 
%     [roff+1 coff+1] element.
% It achieves this result by computing the DFT in the output array without
% the need to zeropad. Much faster and memory efficient than the
% zero-padded FFT approach if [nor noc] are much smaller than [nr*usfac nc*usfac]
[nr,nc]=size(in);
% Set defaults
if exist('roff', 'var')~=1, roff=0;  end
if exist('coff', 'var')~=1, coff=0;  end
if exist('usfac','var')~=1, usfac=1; end
if exist('noc',  'var')~=1, noc=nc;  end
if exist('nor',  'var')~=1, nor=nr;  end
% Compute kernels and obtain DFT by matrix products
kernc=exp((-1i*2*pi/(nc*usfac))*( ifftshift(0:nc-1).' - floor(nc/2) )*( (0:noc-1) - coff ));
kernr=exp((-1i*2*pi/(nr*usfac))*( (0:nor-1).' - roff )*( ifftshift([0:nr-1]) - floor(nr/2)  ));
out=kernr*in*kernc;
return
end

function [ imFTout ] = FTpad(imFT,outsize)
% imFTout = FTpad(imFT,outsize)
% Pads or crops the Fourier transform to the desired ouput size. Taking 
% care that the zero frequency is put in the correct place for the output
% for subsequent FT or IFT. Can be used for Fourier transform based
% interpolation, i.e. dirichlet kernel interpolation. 
%
%   Inputs
% imFT      - Input complex array with DC in [1,1]
% outsize   - Output size of array [ny nx] 
%
%   Outputs
% imout   - Output complex image with DC in [1,1]
% Manuel Guizar - 2014.06.02
if ~ismatrix(imFT)
    error('Maximum number of array dimensions is 2')
end
Nout = outsize;
Nin = size(imFT);
imFT = fftshift(imFT);
center = floor(size(imFT)/2)+1;
imFTout = zeros(outsize);
centerout = floor(size(imFTout)/2)+1;
% imout(centerout(1)+[1:Nin(1)]-center(1),centerout(2)+[1:Nin(2)]-center(2)) ...
%     = imFT;
cenout_cen = centerout - center;
imFTout(max(cenout_cen(1)+1,1):min(cenout_cen(1)+Nin(1),Nout(1)),max(cenout_cen(2)+1,1):min(cenout_cen(2)+Nin(2),Nout(2))) ...
    = imFT(max(-cenout_cen(1)+1,1):min(-cenout_cen(1)+Nout(1),Nin(1)),max(-cenout_cen(2)+1,1):min(-cenout_cen(2)+Nout(2),Nin(2)));
imFTout = ifftshift(imFTout)*Nout(1)*Nout(2)/(Nin(1)*Nin(2));
return
end

%% ------------------------------------------------------------
function textprogressbar(c,initmaxcalls)
    % This function creates a text progress bar, originally from Paul Proteus (e-mail: proteus.paul (at) yahoo (dot) com).
    % Example:
    % updatetextprogressbar = parallel.pool.DataQueue;
    % afterEach(updatetextprogressbar, @textprogressbar);
    % N = 50;
    % textprogressbar('start ',N); % call the funtion with two arguments for init
    % parfor ii = 1:N
    %   send(updatetextprogressbar,[' additions text - current N=' num2str(ii) ' '] ); % this send accepts only 1 argument, a string, it can be []
    %   pause(0.1);                % your code or whatever
    % end
    % textprogressbar(' end ',0);  % call the funtion with two arguments also for exit
    % Initialization
    persistent strCR calls_since_init maxcalls; %   Carriage return as pesistent variable, as well as calls_since_init and maxcalls
    % Vizualization parameters
    strPercentageLength = 10;   %   Length of percentage string (must be >5)
    strDotsMaximum      = 10;   %   The total number of dots in a progress bar
    % Main
    if nargin == 2 % init/exit calls
        if isempty(strCR) && ~ischar(c)     % Progress bar must be initialized with a string
            error('The text progress must be initialized with a string');
        elseif isempty(strCR) && ischar(c)  % Progress bar - initialization
            fprintf('%s',c);strCR = -1;calls_since_init = 0; maxcalls = initmaxcalls;
        elseif ~isempty(strCR) && ischar(c) % Progress bar  - termination
            strCR = [];fprintf([c '\n']);
        end
    else % Progress bar - normal progress, only one argument, here c for additional infos in the line
        calls_since_init = calls_since_init+1; % update the number of calls
        percent = floor(calls_since_init/maxcalls*100);
        percentageOut = [num2str(percent) '%%'];
        percentageOut = [percentageOut repmat(' ',1,strPercentageLength-length(percentageOut)-1)];
        nDots = floor(percent/100*strDotsMaximum);
        dotOut = ['[' repmat('.',1,nDots) repmat(' ',1,strDotsMaximum-nDots) ']'];
        strOut = [percentageOut dotOut c];
        % Print it on the screen
        if strCR == -1     % Don't do carriage return during first run
            fprintf(strOut);
        else % Do it during all the other runs, strCR removes line from last call
            fprintf([strCR strOut]);
        end
        % Update carriage return to remove output from last call
        strCR = repmat('\b',1,length(strOut)-1);
    end
end

